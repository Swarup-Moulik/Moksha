println("==== ENUM SUITE ====")

// --- 1. C-Style Auto-Increment ---
// Values should default to 0, 1, 2
enum Status {
    Idle,
    Running,
    Stopped
}

println("\n[1. C-Style Auto-Increment]")
println("Idle (Expect 0): " + Status.Idle)
println("Running (Expect 1): " + Status.Running)
println("Stopped (Expect 2): " + Status.Stopped)

// --- 2. Explicit Assignment (TS Style - Integer only for now) ---
// You can assign specific integers to keys.
enum HttpCode {
    OK = 200,
    BadRequest = 400,
    ServerErr = 500
}

println("\n[2. Explicit Assignment]")
println("OK: " + OK)
println("BadRequest: " + BadRequest)
println("ServerErr: " + ServerErr)

// --- 3. Mixed Auto-Increment ---
// If you assign one, the next should increment from there.
enum Levels {
    Low = 10,
    Medium, // Should be 11
    High = 20,
    Critical // Should be 21
}

println("\n[3. Mixed Assignment]")
println("Low (10): " + Low)
println("Medium (11): " + Medium)
println("High (20): " + High)
println("Critical (21): " + Critical)

// --- 4. Using Enums in Logic ---
println("\n[4. Enums in Switch/If]")

int currentStatus = Running

if (currentStatus == Running) {
    println("System is RUNNING (Pass)")
} else {
    println("System is NOT running (Fail)")
}

switch (currentStatus) {
    case Idle: { println("Switch: Idle") }
    case Running: { println("Switch: Running (Pass)") }
    case Stopped: { println("Switch: Stopped") }
    default: { println("Switch: Unknown") }
}

println("\n=== ENUM TEST COMPLETED ===")

println("==== MACRO SYNTAX SUITE ====")

// Definition test
macro log(msg) {
    println("[LOG MACRO]: " + msg)
}

macro performCalc(x, y) {
    int result = x + y
    println("Calc Result: " + result)
}

println("Macros defined successfully.")
println("(Note: Macros do not execute at runtime in current version)")

log("System Start")
performCalc(10, 20)

println("=== MACRO TEST COMPLETED ===")

println("==== PROFESSIONAL ERROR HANDLING SUITE ====")

// =========================================================
// SECTION 1: ARITHMETIC SAFETY
// Goal: Ensure the VM catches math errors instead of segfaulting/crashing.
// =========================================================
println("\n[1. Arithmetic Safety]")

// Test 1.1: Integer Division by Zero
try {
    int a = 100
    int b = 0
    println("  [Test 1.1] Attempting Int Div by Zero (100 / 0)...")
    int res = a / b
    println("  FAIL: Operation proceeded with result: " + res)
} catch (e) {
    println("  PASS: Caught Arithmetic Exception: " + e)
}

// Test 1.2: Modulo by Zero
try {
    println("  [Test 1.2] Attempting Modulo by Zero (100 % 0)...")
    int res = 100 % 0
    println("  FAIL: Operation proceeded with result: " + res)
} catch (e) {
    println("  PASS: Caught Arithmetic Exception: " + e)
}

// Test 1.3: Double Division by Zero (Expect Infinity or Exception depending on implementation)
// Note: Many languages allow 10.0/0.0 -> Infinity. If you throw, it passes.
try {
    double x = 10.0
    double y = 0.0
    println("  [Test 1.3] Attempting Double Div by Zero (10.0 / 0.0)...")
    double res = x / y
    println("  INFO: Result was: " + res + " (Infinity is acceptable for Doubles)")
} catch (e) {
    println("  PASS: Caught Arithmetic Exception: " + e)
}


// =========================================================
// SECTION 2: MEMORY & BOUNDS SAFETY
// Goal: Verify memory protection prevents buffer overflows/segfaults.
// =========================================================
println("\n[2. Memory & Bounds Safety]")

// Test 2.1: Array Out of Bounds (Positive)
try {
    int arr[] = [1, 2, 3]
    println("  [Test 2.1] Accessing index 5 of size 3 array...")
    int val = arr[5]
    println("  FAIL: Retrieved value: " + val)
} catch (e) {
    println("  PASS: Caught IndexOutOfBounds: " + e)
}

// Test 2.2: Array Out of Bounds (Negative)
try {
    int arr[] = [1, 2, 3]
    println("  [Test 2.2] Accessing index -1...")
    int val = arr[-1]
    println("  FAIL: Retrieved value: " + val)
} catch (e) {
    println("  PASS: Caught IndexOutOfBounds: " + e)
}

// Test 2.3: String Index Out of Bounds
try {
    string s = "abc"
    println("  [Test 2.3] Accessing char at index 10 of 'abc'...")
    string c = s[10]
    // Note: Some languages return empty string, strictly typed ones throw.
    if (c == "") {
        println("  WARN: Returned empty string (permissive behavior)")
    } else {
        println("  FAIL: Retrieved char: " + c)
    }
} catch (e) {
    println("  PASS: Caught IndexOutOfBounds: " + e)
}


// =========================================================
// SECTION 3: TYPE INTEGRITY & CASTING
// Goal: Ensure invalid type conversions are caught safely.
// =========================================================
println("\n[3. Type Integrity]")

// Test 3.1: Invalid String to Int Cast
try {
    any badStr = "NotAnNumber"
    println("  [Test 3.1] Casting 'NotAnNumber' to int...")
    // This requires runtime.cpp to check if string contains digits before converting
    int val = int(badStr) 
    println("  INFO: Converted to: " + val + " (0 is standard C behavior, Exception is stricter)")
} catch (e) {
    println("  PASS: Caught FormatException: " + e)
}

class Dummy { void act() {} }

// Test 3.2: Null Pointer Dereference (Method Call)
try {
    
    Dummy? d = null
    println("  [Test 3.2] Calling method on null object without optional chaining...")
    d.act() // Should throw NullReferenceException
    println("  FAIL: Method call proceeded on null")
} catch (e) {
    println("  PASS: Caught NullReferenceException: " + e)
}


// =========================================================
// SECTION 4: CONTROL FLOW INTEGRITY
// Goal: Verify nested exceptions and stack unwinding.
// =========================================================
println("\n[4. Control Flow Integrity]")

// Test 4.1: Exception bubbling from function
void thrower() {
    throw "ErrorInFunction"
}

void caller() {
    thrower()
}

try {
    println("  [Test 4.1] Exception bubbling up stack...")
    caller()
    println("  FAIL: Stack did not unwind")
} catch (e) {
    println("  PASS: Caught bubbled exception: " + e)
}

// Test 4.2: Finally block execution on Error
println("  [Test 4.2] Verifying 'finally' execution...")
boolean finallyRun = false
try {
    try {
        throw "Boom"
    } finally {
        finallyRun = true
        println("    -> Inner finally executed")
    }
} catch (e) {
    if (finallyRun) {
        println("  PASS: Finally ran before catch block finished")
    } else {
        println("  FAIL: Finally block skipped")
    }
}

// =========================================================
// SECTION 5: RESOURCE LIMITS (Stress Test)
// Goal: Ensure the VM handles allocation failures gracefully (optional/advanced).
// =========================================================
println("\n[5. Resource Limits (Stress Test)]")

try {
    println("  [Test 5.1] Allocating negative array size...")
    int negArr[-5]; // Should fail immediately
    println("  FAIL: Allocated negative size array")
} catch (e) {
    println("  PASS: Caught AllocationException: " + e)
}

println("\n=== PROFESSIONAL SUITE COMPLETED ===")